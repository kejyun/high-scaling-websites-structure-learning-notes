# 設定快取

對於同樣不常異動的資料，若有大量使用者存取，我們通常為把資料設為快取（可以存放在記憶體或檔案中），在下次有其他使用者要來存取相同資料的時候，不去資料庫重新撈取資料，直接將快取的資料回傳給使用者，可以減少資料庫的存取，增加系統處理使用者請求的效能。

## 以部落格文章快取為例

我們會透過文章編號存取部落格文章，像是 `/posts/1` 或 `/posts/2`，以 PHP Laravel Framework 為例，我們可能透過這樣的方式去處理存取部落格文章：

```php
<?php

// 快取 key 依照不同的文章編號，可以是 blog_post:1 或 blog_post:2
$cache_key = 'blog_post:' . $post_id;

// 快取時間為 60 分鐘
//（在 Laravel 的快取方法時間是以分鐘為計，若是原生的快取方法則是以秒數為計，所以要存放 60 分鐘則必須設定為 60 * 60 = 3600）
$cache_minutes = 60;

if (Cache::has($cache_key)) {
  return Cache::get($cache_key);
}

$results = DB::select('SELECT * FROM `posts` WHERE `post_id` = ?', [$post_id]);

if ($result !== null) {
  // 若有找到該文章資料，則設定快取，讓下一位使用者再次存取相同文章時可直接取用快取
  Cache::put($cache_key, $results, $cache_minutes);
}

return $result;
```

我們會先判斷部落格文章的快取是否存在，若有則直接回傳快取資料，若沒有則重新去資料庫撈取文章資料，在撈取完資料後則設定該文章資料的快取，這樣的話之後有其他使用者要存取相同的部落格文章，則直接從快取拿資料就好，不用再到資料庫去撈取資料，減少資料庫的存取，以提升快取的存取效率。

快取的失效時間必須要依你自己的應用去設定，因為快取大多是放在的記憶體當中（Memcached、Redis）這樣 I/O 存取速度才會快，但是記憶體是`有限`的昂貴資源，除非資料需要一直做快取讓使用者存取，否則快取通常不會設定過長的失效時間，希望失效後自動清除並釋放記憶體資源給其他的快取或應用做使用。

若 $ 夠多，能夠買夠多的記憶體，將快取失效時間設為 1 個月，甚至是更大也沒差，端看自己的`硬體狀況`及`資料需要存放狀況`去決定快取的時間。
